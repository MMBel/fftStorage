# fftStorage
C++ класс для получения АЧХ из монофонического звукового файла.
Использует библиотеку <a href="https://github.com/mborgerding/kissfft">kiss-fft</a>

Класс принимает на вход массив сэмплов, производит Быстрое Преобразование Фурье и создает массив с его амплитудно-частотной характеристикой, предоставляя интерфейсы для запросов к этому массиву.

### Порядок использования:
#### Создаем экземпляр:
```fftStorage fstor;```
#### Устанавливаем параметры:
- ```fstor.setSampleRate(44100)```   // Частота дискретизации (22050 | 44100 | 48000 | 96000 | 192000 )
- ```fstor.setFrameSize(8192)```     // Размер кадра БПФ (1024 | 2048 | 4096 | 8192 | 16384 | 32768 )
- ```fstor.setFreqLimit(20000)```    // Фильтр ВЧ, частоты выше 20000 отбрасываются
- ```fstor.setAveraging(4)```        // Преобразовываются 4 кадра со смещением 1/16 относительно предыдущего, каждая запрошенная точка будет являться усредненной

Устанавливаем оконную функцию Ханна, калибруем амлификатор под нее и очищаем приемный буфер:

```fstor.Clear("Hann");```

Происходит проверка БПФ на тестовой синусоиде и вычисляется коэффициент амплификации для преобразования "магнитуды" или амплитудной характеристики БПФ в исходную амплитуду.

 Надо заметить, что амплификатор корректно восстановит амплитуду только если сигнал занимает весь кадр, а если только половину кадра, то полученная амплитуда будет уменьшена вдвое.
 
#### Опционально: 
Тестируем отклонение точности определения исходной амплитуды ```fstor.TestDeviation()```

 Происходит вычисление амплитуд ряда частот от 10 Гц до FreqLimit и полученные значения амплитуд сравниваются с исходной амплитудой.
 
 Функция возвращает максимальное отклонение от нее в децибелах и очищает буфер.
 
 Примечание: величина отклонения зависит от выбранной оконной функции и только от этого.
 
 Стандартный результат:
<table border=0>
 <tr><td>Rectangular</td><td>-17 dB</td></tr>
 <tr><td>Welch</td><td>-22 dB</td></tr>
 <tr><td>Bartlett</td><td>-23 dB</td></tr>
 <tr><td>Hamming</td><td>-24 dB</td></tr>
 <tr><td>Hann</td><td>-25 dB</td></tr>
 <tr><td>Gaussian25</td><td>-25 dB</td></tr>
 <tr><td>Blackman</td><td>-28 dB</td></tr>
 <tr><td>BlackmanHarris</td><td>-30 dB</td></tr>
 <tr><td>Gaussian35</td><td>-30 dB</td></tr>
 <tr><td>Gaussian45</td><td>-34 dB</td></tr>
</table>

 Из этого явствует, что наибольшую точность определения амплитуды дает оконная функция <b>Gaussian45</b>
#### Добавляем сэмплы:
```fstor.AddSample(float Value);```

Можно добавлять сэмплы в любом количестве, старые данные из буфера удаляются автоматически.

#### Производим БПФ: 
```fstor.DoFFT();```

После этого шага можем запрашивать данные АЧХ.

Для вывода этих данных используется структура fpoint, содержащая порядковый номер точки в массиве, ее частоту и амплитуду.

#### Получаем приблизительную точку максимума по известной примерной частоте, задав максимальную ширину шага в стороны от нее
(каждый шаг частоты равен SampleRate/FrameSize):

```c
fpoint pnt = fstor.GetMaxOptimized(Frequency, 1);
cout << pnt.Frequency << " " << pnt.Amplitude << endl;
```

Производится уточнение частоты точки максимума путем построения перевернутой параболы к его соседним точкам и выдача вершины в виде fpoint.

Это означает, что эта точка не существует в хранилище, ее существование лишь предполагается. Кроме того, не всегда возможно построить параболу по трем точкам, поэтому в случае получения некорректных значений, или если разница между амплитудой ближайшей точки и этой превышает 500 (в диапазоне амплитуд 0-32767), то вместо возможной вершины параболы берется ближайшая реальная точка.

#### Перебираем все точки последовательно (например для построения графика):
```cpp
fpoint pnt;
for (unsigned  i=0; i<fstor.AmountPnt; ++i)
{
 pnt = fstor.GetPointOptimized(i);
 cout << pnt.Frequency << " " << pnt.Amplitude << endl;
}
```

#### Сохраняем дамп хранилища: 
```fstor.SaveStorage("c:\\Storage.txt");```

#### Очищаем буфер если надо: 
```fstor.Clear();```

Примеры использования см main.cpp
 
 
